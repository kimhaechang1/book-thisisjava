https://en.wikipedia.org/wiki/Database_transaction

https://tecoble.techcourse.co.kr/post/2021-07-11-database-transaction/

## 트랜잭션

데이터베이스 트랜잭션은 DBMS 내에서 수행되는 작업의 단위이다.

DB의 데이터를 변경하는 모든사항이 해당된다.

이러한 DB는 데이터의 무결성을 가장 중요하게 여기고

이러한 무결성을 달성하기 위해 아래의 특성을 가진다.

원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 내구성(Durability)

### 원자성

예를들어 입금 이라는 하나의 작업은

어떤 계좌 A에서 일정 금액을 인출하여 계좌 B로 옮기는 작업이다.

데이터적으로 생각해보면 계좌 A에서 금액을 차감하고 계좌 B에 차감한 금액만큼을 더해야 한다.

즉, DBMS 입장에서는 입금이라는 하나의 트랜잭션 내에서 A데이터의 변경과 B데이터의 변경이 있는것이다.

여기서 당연하게 생각해볼 수 있는것은

만약 계좌 A에서의 인출도중 에러가 발생한다면

해당 인출 작업(트랜잭션)은 당연히 무산되어 각각의 계좌 A와 계좌 B에 영향을 주지 않아야 한다.

이는 A에서 성공적으로 돈을 인출했지만,

B에 대해서 입금이 실패하였더라도 마찬가지로 해당 작업이 작업시작전으로 돌아가야한다.

이때, 이렇게 작업 시작전으로 돌아가는것을 롤백(rollback) 이라고 한다.

이렇게 하나의 작업당 성공한다는 하나의 조건만을 가지며, 작업 도중에 문제가 발생한다면 작업전의 상태로 돌아가야 하는것을 원자성이라고 한다.

### 일관성

일관성(Consistency)은 트랜잭션이 완료된 결과값이 해당 데이터베이스의 제약조건을 위반해서는 안된다는 것이다.

예를들어 학교에 반을 나타내는 테이블이 있고

반 내에 학생을 나타내는 테이블이 있으며

해당 학생 테이블에는 '모든 학생은 반 번호를 가지며, 반 번호는 학교 테이블 내에 있는 반 번호여야 한다.'라는 제약 조건이 있다고 가정하자.

여기서 만약 학교 테이블에 없는 반번호를 가진 학생을 추가하려 한다면, 위의 제약조건을 위반하는 행위가 되므로

실제 테이블에는 영향을 주지 않은채로 무시되어야 한다.

이러한 특성 덕분에 데이터베이스 내에 데이터들은 그들의 제약조건에 맞게 일관성을 유지할 수 있다.

### 독립성

독립성(Isolation)은 정의 상으로는 모든 트랜잭션은 서로 독립적으로 수행되어야 한다는 것

이러한 독립성은 그 격리수준에 따라 4가지 존재한다.

https://mangkyu.tistory.com/299

SERIALIZABLE: 가장 엄격한 수준, 이름 그대로 트랜잭션들을 순차적으로 처리한다.

REPEATABLE READ: 일반적으로 RDBMS에서는 하나의 데이터에 대한 변경전 사항을 백업해둔다.

이렇게 하나의 데이터에 대해서 여러 버전이 존재하는 것을 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어) 라고 부른다.

이러한 격리수준에서는 트랜잭션들이 순차적인 번호가 매겨지며, 각각의 트랜잭션 번호에 따른 백업 데이터가 존재한다.

따라서 자신보다 늦게 시작하여 일찍 종료된 트랜잭션이 먼저 시작한 자신이 조회한 데이터에 변경사항을 일으켰을 때도

해당 변경된 데이터가 아니라 자신이 조회한 시점의 데이터를 불러올 수 있다.

하지만 이 격리수준은 새로운 데이터가 추가되거나 삭제되는 경우에 PHANTOM READ가 일어나서 부정합이 생길 수 있다.

PHANTOM READ란? 하나의 트랜잭션 내에서 특정 데이터가 보였다가 안보였다가 유령처럼 읽힌다고 하여 붙은 말이다.

데이터베이스는 락이 있고, 일반적인 RDMBS에서는 레코드 수준의 락을 제공한다.

만약 락을 걸지않은 체로 조회한다면, DBMS는 트랜잭션 로그의 데이터와 실제 데이터를 비교하여 해당 트랜잭션 내에 원자성이 깨지지 않도록 데이터를 제공한다.

그리고 이러한 락을 걸었을 때에는 트랜잭션 백업로그에서 비교하지도 않고 바로 DB에서 데이터를 들고오게 된다.

READ COMMITTED: 커밋된 데이터만 존재할 수 있다.

이 격리수준은 유령 리드에 반복읽기 불가능 문제까지 더해진다.

반복 읽기 불가능은 말그대로 격리수준 REPEATABLE READ가 불가능하단 얘기고

이는 서로다른 두 트랜잭션이 하나의 데이터에 대해서 접근할 때, 먼저 커밋된 트랜잭션이 데이터를 변경시켰다면,

작업이 덜끝난 트랜잭션에서 다시 조회할때 변경된 데이터가 그대로 반영되어 있게 된다.

READ UNCOMMITTED: 커밋하지 않은 데이터에도 접근이 가능하다.

이는 트랜잭션끼리의 독립성이 보장되지 않는 트랜잭션이므로 거의 사용되지 않는다.

예를들어서 두 트랜잭션이 동시에 시작되고 둘다 아직 커밋되지 않은 상태라고 가정하자

트랜잭션 A가 테이블 T에 접근하여 데이터를 insert하였다.

다른 트랜잭션 격리수준과는 달리 커밋되지 않은 상태도 다른트랜잭션이 엿볼수 있으므로

트랜잭션 B에서 테이블 T에 접근하여 조회하면 A가 insert한 데이터가 조회되게 된다.

이렇게 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있는 현상을 Dirty Read 라고 한다.

### 지속성(내구성)

지속성은 트랜잭션이 종료된 후, 즉 커밋된 후에는 DB에 해당 트랜잭션 동안의 작업이 반영될 것이다.

이렇게 반영된 데이터는 데이터베이스의 시스템에 무슨일이 일어나더라도 영구적으로 반영되어야 한다.
